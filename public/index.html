<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Followed</title>
    <script
      type="module"
      src="https://unpkg.com/ap-banner@0.0.7/index.js"
    ></script>
    <style>
      ap-banner {
        transition: opacity ease 1s;
        min-height: 1rem;
      }
      ap-banner:not(:defined) {
        opacity: 0;
      }
      ap-banner:defined {
        opacity: 1;
      }

      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <ap-banner title="Followed: A passion project featuring maze generation"
      ><div slot="more-info">
        With "Followed", I wanted to create a simple game that gave the
        exprience of exploring a labyrinth. It features randomly generated
        mazes, a simple 'camera', fog of war, and enemies with AI of varying
        complexity.
        <br /><br />
        I got an
        <a href="http://www.mazesforprogrammers.com/" target="_blank"
          >excellent book on maze generation</a
        >
        last christmas (2019), which taught me more or less everything I know on
        the subject. In general, maze algorithms involve creating a spanning
        tree structure by connecting nodes, where edges are 'passages' and
        vertices are 'cells'. This randomly requests a maze generated by one of
        three algorithms I've implemented to date.
        <br /><br />
        I took this project as an opportunity to learn rust, and deploy a
        community supported lambda runtime using the serverless framework. I
        found rust a lot of fun to work with, although I would say it has a
        learning curve, owing to its extensive vocabulary. Rust enabled me to
        easily work with byte level data, which allowed me to create a hyper
        efficient transport encoding for the mazes. Each maze is a flat vector
        of bytes, where each cell is a byte. The passages are simply represented
        as positive bits. Check out the library I wrote to drive this project
        <a href="https://github.com/animate-object/mazes" , target="_blank"
          >here</a
        >. <br /><br />
        The API is actually capable of rapidly generating much larger mazes than
        the web application can draw. I hope to reuse it in a more intricate, 3D
        project some day.
        <br /><br />
        For testing purposes I exposed the same underlying maze generation logic
        as a CLI that you can install with cargo.
        <a href="https://github.com/animate-object/maze-cli" target="_blank"
          >Check it out on github</a
        >.
      </div></ap-banner
    >
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
